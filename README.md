
# はじめの一歩

UiPathで使える関数を調べる。  
結局のところ、何がどう使えるのかわからんので
調べることにした。  
ちなみにUiPathで利用する関数は」VB.Netをベースとする。

具体例とともに書く  

関数名、引数、戻り値を書く  
その際、データ型も書く  

アクティビティについても書く  
アクティビティはどういうときに使うかと
利用時の注意事項を書く

[UiPath 公式](https://docs.uipath.com/studio/lang-ja)

# フロー制御(条件分岐)

UiPathにおいて条件分岐は
条件分岐アクティビティとフロー条件分岐アクティビティの2つが存在する。  

## 条件分岐アクティビティ

シーケンスアクティビティの中で利用される通常の条件分岐  
特徴としては条件式と合わせてif-elseを書くという  
プログラマーが一番イメージしやすいアクティビティ  
シーケンス条件分岐と呼ぶとしっくりきそう。

## フロー条件分岐アクティビティ

フローチャートアクティビティの中で利用される条件分岐  
特徴としては中に書くが条件式だけというところ  
そのあとの処理は左右に枝分かれた状態で定義する。  

条件が多い時に利用すると前述のシーケンス条件分岐よりも  
多少アクティビティの連結が長くなるが  
アクティビティの見通しを良くするということに貢献しそうではある。

# 関数・メソッド一覧

## Split

[UiPath道場 - カンマ区切り文字列を分割する](http://www.uipath-dojo.com/purpose/string_split.html)

文字列分割の関数

Split(文字列,区切り文字) 

``` VB

Split("1,2,3",",")(0) ' 1
Split("1,2,3",",")(1) ' 2
Split("1,2,3",",")(2) ' 3

```

## left

指定された分だけ左から文字列を取り出す関数

``` VB

test = "abcde"
left(test,1) ' a

```

## instr

文字列から特定の文字を探す関数
見つかった場合は見つかった位置を返し見つからない場合は0を返す。

```  VB

test = "abcde"
instr(test,"a") ' 1

```


## Replace

文字列置換の**メソッド**  
**関数ではなくメソッド**

``` VB

' あらかじめ文字列変数sValを宣言しておく
' sVal = "あいうえお"

' 変数代入のアクティビティを利用
sVal = sVal.Replace("あ","か")

' sVal:かいうえお

```

## contains

文字列検索の**メソッド**
**関数ではなくメソッド**


``` VB

' あらかじめ文字列変数sValを宣言しておく
' sVal = "あいうえお"

sVal.contains("あ") ' True
sVal.contains("か") ' False


```

# 特殊なデータ型

## DataTable

> ザックリ言うと、表形式のデータを保存できるデータ型  
VBAでいうところの**IHTMLTableObject**に使い方が似ている。

|番号|名前|
|:---|:---|
|1|ジョン|
|2|リーナス|
|3|ジョブズ|

上記のようなDataTable型変数tblを作成した時の動きを考えると

``` VB

tbl.Rows(1)("名前") ' リーナス

tbl.Rows(1).item(1) ' リーナス

```

DataTableにヘッダ(列の説明)がない場合は参照する番号がズレる

``` VB

tbl.Rows(1).item(2)' リーナス

```

また、テーブルオブジェクトは意図して生成するか  
画面上、Excelなどから取得してオブジェクトを生成しなければならない。

オブジェクトを生成しなければならない理由としては  
スキーマ、列の定義が必要だからだと思われる。

データの追加、削除をデータテーブルに対して行う場合はアクティビティを通して実行する必要がある。

# ファイル・ディレクトリ操作

## ディレクトリ配下のファイルを全て取得

Microsoft Scripting Runtimeでいうところの  
「FileSystemObject」で利用できる「GetFolder(args).GetFiles」に相当する。

ディレクトリ配下のtxtを全て取得する場合は  
Array of [String]で変数を宣言して代入アクティビティで代入すれば良い。

``` CS
fileList = System.IO.Directory.GetFiles(strFolder,”*.txt”)
```

上記のString型の配列、fileListからデータを取り出す際は
For eachアクティビティを利用することで順に取り出すことが可能である。

## OS上の特殊なディレクトリを取得

Windowsにはあらかじめ用意された特殊なディレクトリが存在する。  
UiPathで利用する場合は「Get Environment Folder」 を活用する。

デスクトップのルートディレクトリを指定する場合はDesktopを指定する。

## ファイル名から拡張子を除いた部分だけ取得

``` VB

filename = "test.csv"
tmp = left(filename,instr(filename,".")-1)

```

# シナリオをより速く作るには

## アクティビティパターンを知ること
UIに対応するアクティビティを知る。  
例えば、実際に経験したことで  
OracleFormはSetTextアクティビティではなく  
TypeIntoアクティビティを使わないと
文字列を入力できない。 

## アクティビティの仕様を知ること
例えば、SetVisibleTextを使う場合は  
画面上に表示された文字列を取得するので  
事前に画面の最大化などをして画面表示の担保する必要がある。

## メタデータのことは後から考えること
利用するデータのデータ設計は必要だが  
それを最初に持ってくると効率化悪いので  
とりあえず、作ってみる。  
このときに重要なことは
メタデータをアクティビティに直接書かず  
変数で定義してからアクティビティに入れる。  
そして、変数の既定値にテスト用のメタデータを設定する。


## 同じサブシナリオを作らないこと
よくある動作はどこでも使えるので  
ライブラリ化することで再利用できる？？  

アクティビティに引数を渡すように作る。
例えば  
ブラウザの名前をつけて保存の場合は  
ファイルのフルパスを与える作りでライブラリ化することで
使いまわせるのでは


# Microsoft Excel Visual Basic for Application の 小ネタ

## セルの操作

レンジ指定のセル貼り付けよりもセルオブジェクト操作による貼り付けのほうが早い。  
値を代入するだけであればもちろん、直接代入するほうが早い。

レンジ指定のセル貼り付け < セルオブジェクト操作による貼り付け < 直接代入

ゆえにPasteSpecialメソッドを複数回に渡って実行するのであれば
直接、値を代入してあげたほうが早い。

## イベント

Excelは常にイベント発生を監視している為
その分、セルやワークシートを操作したときに遅延が生じる。  
イベントの類を抑えたい場合は  
Applicationオブジェクトの「EnableEvents」プロパティをfalseに設定する。


## Range と Cells

どちらでも基本、セルを操作することは可能だがスピードを求める場合は  
Cellsのほうが若干ながら早い。  
早い理由としてCellsは縦横のアドレスを指定しているのに対して
Rangeは利用する度に座標変換が入る為、遅延が生じる。


## コピーして挿入

Insertメソッド利用前にCopyメソッドを実行すると  
コピーして挿入することが可能

## 1年間の営業日だけを取り出したい

``` VB
worksheetFunction.Workday(開始日,日数,祭日リスト)
```
開始日を明日の日付に設定して  
結果をテキストにするとX行数=X営業日目になる。

## よく使うWorksheet Function

- MAX
- ROW
- INDEX
- IFERROR
- IF
- COUNTIF
- COUNTIFS

## Is～

- IsError

valueが起きているセルなどを検出できます。

- IsEmpty

- IsNothing

※Is Nothing の方が少し動作が速いが無視できるレベル
IsNothing関数は値型の変数に対しても使えるのに対し  
Is Nothingは値型の変数に対して使用するとビルドエラーになります

